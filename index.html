<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diffraction Coneê³¼ Flat Detectorì˜ ê¸°í•˜í•™</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
        }
        h2 {
            color: #3498db;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        canvas {
            border: 1px solid #ddd;
            border-radius: 5px;
            display: block;
            margin: 20px auto;
            background: white;
        }
        .explanation {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }
        .key-point {
            background: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        input[type="range"] {
            width: 300px;
            margin: 0 10px;
        }
        .value-display {
            display: inline-block;
            min-width: 80px;
            font-weight: bold;
            color: #e74c3c;
        }
        label {
            font-weight: bold;
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”¬ Diffraction Coneê³¼ Flat Detectorì˜ ê¸°í•˜í•™</h1>
        
        <h2>1. Side View (ì¸¡ë©´ë„) - í•µì‹¬ ê°œë…</h2>
        <canvas id="sideViewCanvas" width="800" height="500"></canvas>
        
        <div class="controls">
            <label for="angleSlider">2Î¸ ê°ë„:</label>
            <input type="range" id="angleSlider" min="5" max="60" value="20" step="1">
            <span class="value-display" id="angleValue">20Â°</span>
        </div>
        
        <div class="explanation">
            <h3>ğŸ“ ë¬´ì—‡ì„ ë³´ê³  ìˆë‚˜ìš”?</h3>
            <p><strong>ë¹¨ê°„ ì„ :</strong> X-ray beamì´ sampleì—ì„œ ì‚°ë€ë˜ì–´ ë‚˜ê°€ëŠ” diffraction cone (ì›ë¿”)</p>
            <p><strong>íŒŒë€ ì„ :</strong> Flat detector (í‰ë©´ ê²€ì¶œê¸°)</p>
            <p><strong>ì´ˆë¡ ì :</strong> Coneê³¼ detectorê°€ ë§Œë‚˜ëŠ” êµì°¨ì ë“¤</p>
            <p><strong>ì£¼í™© ì›:</strong> "ì´ìƒì ì¸" ì›í˜• ê¶¤ì  (Lab XRDì²˜ëŸ¼ curved detectorë¥¼ ì“¸ ë•Œ)</p>
        </div>

        <h2>2. Front View (ì •ë©´ë„) - Detectorì—ì„œ ë³¸ ëª¨ìŠµ</h2>
        <canvas id="frontViewCanvas" width="800" height="600"></canvas>
        
        <div class="key-point">
            <h3>âš ï¸ í•µì‹¬ í¬ì¸íŠ¸!</h3>
            <p><strong>Low angle (2Î¸ = 10~20Â°):</strong> ì´ˆë¡ ì ë“¤ì´ ê±°ì˜ ì™„ë²½í•œ ì›í˜• â†’ ì˜¤ì°¨ ì‘ìŒ</p>
            <p><strong>High angle (2Î¸ = 40~60Â°):</strong> ì´ˆë¡ ì ë“¤ì´ ì£¼í™© ì›ì—ì„œ ë²—ì–´ë‚¨ â†’ ì˜¤ì°¨ ì¦ê°€!</p>
            <p>ìŠ¬ë¼ì´ë”ë¥¼ ì›€ì§ì—¬ì„œ ê°ë„ë¥¼ ë°”ê¿”ë³´ì„¸ìš”. High angleë¡œ ê°ˆìˆ˜ë¡ distortionì´ ì»¤ì§€ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
        </div>

        <h2>3. ìˆ˜í•™ì  ì„¤ëª…</h2>
        <div class="explanation">
            <h3>ì™œ ì´ëŸ° ì¼ì´ ë°œìƒí•˜ë‚˜?</h3>
            <p><strong>Diffraction Cone:</strong> 3D ì›ë¿” í‘œë©´ (ë°©ì •ì‹: xÂ² + yÂ² = (zÂ·tan(2Î¸))Â²)</p>
            <p><strong>Flat Detector:</strong> 2D í‰ë©´ (z = constant)</p>
            <p><strong>êµì°¨:</strong> ì´ë¡ ì ìœ¼ë¡œëŠ” ì›ì´ì§€ë§Œ, coneì˜ ê¸°ìš¸ê¸°ê°€ ì»¤ì§ˆìˆ˜ë¡ (high angle) í‰ë©´ê³¼ì˜ êµì°¨ê°€ ì™œê³¡ë¨</p>
            <br>
            <p><strong>ê¸°í•˜í•™ì  ê´€ê³„:</strong></p>
            <p>â€¢ Ideal (ì›í˜• detector): r = d Ã— tan(2Î¸)</p>
            <p>â€¢ Flat detectorì—ì„œ: r_measuredëŠ” detector ê°€ì¥ìë¦¬ë¡œ ê°ˆìˆ˜ë¡ r_idealë³´ë‹¤ ì»¤ì§</p>
            <p>â€¢ ì´ ì°¨ì´ê°€ ë°”ë¡œ geometric distortion!</p>
        </div>

        <h2>4. ì‹¤ì œ ë°ì´í„°ì—ì„œì˜ ì˜í–¥</h2>
        <canvas id="errorPlotCanvas" width="800" height="400"></canvas>
        
        <div class="key-point">
            <p><strong>SDD = 206.5 mm ê¸°ì¤€:</strong></p>
            <p>â€¢ 2Î¸ = 19.11Â° â†’ ì˜¤ì°¨ ~0.035Â° (~2 arcmin)</p>
            <p>â€¢ 2Î¸ = 44.78Â° â†’ ì˜¤ì°¨ ~0.20Â° (~12 arcmin)</p>
            <p>â€¢ 2Î¸ = 60Â° â†’ ì˜¤ì°¨ ~0.45Â° (~27 arcmin)</p>
        </div>
    </div>

    <script>
        // Constants
        const SDD = 206.5; // mm
        
        // Side View Canvas
        const sideCanvas = document.getElementById('sideViewCanvas');
        const sideCtx = sideCanvas.getContext('2d');
        
        // Front View Canvas
        const frontCanvas = document.getElementById('frontViewCanvas');
        const frontCtx = frontCanvas.getContext('2d');
        
        // Error Plot Canvas
        const errorCanvas = document.getElementById('errorPlotCanvas');
        const errorCtx = errorCanvas.getContext('2d');
        
        // Angle slider
        const angleSlider = document.getElementById('angleSlider');
        const angleValue = document.getElementById('angleValue');
        
        function drawSideView(twoTheta) {
            const ctx = sideCtx;
            const width = sideCanvas.width;
            const height = sideCanvas.height;
            
            // Clear
            ctx.clearRect(0, 0, width, height);
            
            // Scale and origin
            const scale = 2.0;
            const originX = 150;
            const originY = height / 2;
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(originX, 0);
            ctx.lineTo(originX, height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, originY);
            ctx.lineTo(width, originY);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#666';
            ctx.font = '14px Arial';
            ctx.fillText('Sample', originX - 35, originY + 20);
            ctx.fillText('â†’ Beam direction', originX + 10, originY - 10);
            
            // Draw sample (dot)
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(originX, originY, 6, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw incoming beam
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(50, originY);
            ctx.lineTo(originX, originY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw diffraction cone (upper and lower lines)
            const twoThetaRad = twoTheta * Math.PI / 180;
            const coneLength = 400;
            
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            
            // Upper cone line
            ctx.beginPath();
            ctx.moveTo(originX, originY);
            const endX1 = originX + coneLength * Math.cos(twoThetaRad);
            const endY1 = originY - coneLength * Math.sin(twoThetaRad);
            ctx.lineTo(endX1, endY1);
            ctx.stroke();
            
            // Lower cone line
            ctx.beginPath();
            ctx.moveTo(originX, originY);
            const endX2 = originX + coneLength * Math.cos(twoThetaRad);
            const endY2 = originY + coneLength * Math.sin(twoThetaRad);
            ctx.lineTo(endX2, endY2);
            ctx.stroke();
            
            // Draw detector plane (vertical line)
            const detectorX = originX + SDD * scale;
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(detectorX, 50);
            ctx.lineTo(detectorX, height - 50);
            ctx.stroke();
            
            // Draw intersection points
            const r = SDD * Math.tan(twoThetaRad);
            const intersectY1 = originY - r * scale;
            const intersectY2 = originY + r * scale;
            
            ctx.fillStyle = '#27ae60';
            ctx.beginPath();
            ctx.arc(detectorX, intersectY1, 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(detectorX, intersectY2, 6, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw ideal circular path (arc)
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            const radius = SDD * scale;
            ctx.beginPath();
            ctx.arc(originX, originY, radius, -twoThetaRad, twoThetaRad);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Annotations
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`2Î¸ = ${twoTheta}Â°`, detectorX + 20, 80);
            ctx.fillText(`r = ${r.toFixed(1)} mm`, detectorX + 20, 105);
            
            // Draw angle arc
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(originX, originY, 80, -twoThetaRad, 0);
            ctx.stroke();
            ctx.fillStyle = '#e74c3c';
            ctx.font = '14px Arial';
            ctx.fillText('2Î¸', originX + 85, originY - 20);
        }
        
        function drawFrontView(twoTheta) {
            const ctx = frontCtx;
            const width = frontCanvas.width;
            const height = frontCanvas.height;
            
            // Clear
            ctx.clearRect(0, 0, width, height);
            
            // Center
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = 1.5;
            
            // Draw beam center
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            // Draw ideal circle (what we'd get with circular detector)
            const twoThetaRad = twoTheta * Math.PI / 180;
            const r_ideal = SDD * Math.tan(twoThetaRad);
            
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(centerX, centerY, r_ideal * scale, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw actual intersection points (simulating distortion)
            ctx.fillStyle = '#27ae60';
            const numPoints = 36;
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                
                // Simulate geometric distortion
                // At edges, points move outward
                const distortionFactor = 1 + 0.5 * (twoTheta / 60) * Math.pow(Math.abs(Math.cos(angle - Math.PI/4)), 2);
                const r = r_ideal * distortionFactor;
                
                const x = centerX + r * scale * Math.cos(angle);
                const y = centerY + r * scale * Math.sin(angle);
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Labels
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('Detector Front View', centerX - 100, 30);
            
            ctx.font = '14px Arial';
            ctx.fillStyle = '#f39c12';
            ctx.fillText('ì£¼í™© ì›: ì´ìƒì ì¸ ì›í˜• (Lab XRD)', 20, height - 60);
            ctx.fillStyle = '#27ae60';
            ctx.fillText('ì´ˆë¡ ì : ì‹¤ì œ intersection (Flat detector)', 20, height - 35);
            
            ctx.fillStyle = '#e74c3c';
            ctx.fillText('Beam center', centerX + 15, centerY - 5);
            
            // Show distortion at corners
            if (twoTheta > 30) {
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                const cornerR = r_ideal * (1 + 0.5 * (twoTheta / 60));
                ctx.arc(centerX, centerY, cornerR * scale, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = '#e74c3c';
                ctx.font = '12px Arial';
                ctx.fillText('â† Distortion zone', centerX + cornerR * scale + 10, centerY);
            }
        }
        
        function drawErrorPlot() {
            const ctx = errorCtx;
            const width = errorCanvas.width;
            const height = errorCanvas.height;
            
            // Clear
            ctx.clearRect(0, 0, width, height);
            
            // Setup
            const marginLeft = 80;
            const marginRight = 40;
            const marginTop = 40;
            const marginBottom = 60;
            const plotWidth = width - marginLeft - marginRight;
            const plotHeight = height - marginTop - marginBottom;
            
            // Draw axes
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(marginLeft, marginTop);
            ctx.lineTo(marginLeft, height - marginBottom);
            ctx.lineTo(width - marginRight, height - marginBottom);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 16px Arial';
            ctx.save();
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Angular Error (degrees)', 0, 0);
            ctx.restore();
            
            ctx.fillText('2Î¸ (degrees)', width / 2 - 50, height - 10);
            ctx.font = 'bold 18px Arial';
            ctx.fillText('Geometric Distortion vs Angle', width / 2 - 120, 25);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = marginLeft + (i / 10) * plotWidth;
                ctx.beginPath();
                ctx.moveTo(x, marginTop);
                ctx.lineTo(x, height - marginBottom);
                ctx.stroke();
                
                const y = marginTop + (i / 10) * plotHeight;
                ctx.beginPath();
                ctx.moveTo(marginLeft, y);
                ctx.lineTo(width - marginRight, y);
                ctx.stroke();
            }
            
            // X-axis labels (2theta)
            ctx.fillStyle = '#2c3e50';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            for (let theta = 0; theta <= 60; theta += 10) {
                const x = marginLeft + (theta / 60) * plotWidth;
                ctx.fillText(theta.toString(), x, height - marginBottom + 20);
            }
            
            // Y-axis labels (error)
            ctx.textAlign = 'right';
            const maxError = 0.5;
            for (let i = 0; i <= 10; i++) {
                const error = maxError * i / 10;
                const y = height - marginBottom - (i / 10) * plotHeight;
                ctx.fillText(error.toFixed(2), marginLeft - 10, y + 5);
            }
            
            // Plot error curve
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let theta = 5; theta <= 60; theta += 0.5) {
                const twoThetaRad = theta * Math.PI / 180;
                const r = SDD * Math.tan(twoThetaRad);
                const error = (r * r / (2 * SDD * SDD)) * Math.sin(twoThetaRad) * Math.cos(twoThetaRad);
                const errorDeg = error * 180 / Math.PI;
                
                const x = marginLeft + (theta / 60) * plotWidth;
                const y = height - marginBottom - (errorDeg / maxError) * plotHeight;
                
                if (theta === 5) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Mark specific points
            const points = [
                {theta: 19.11, color: '#3498db', label: '19.11Â°'},
                {theta: 44.78, color: '#9b59b6', label: '44.78Â°'}
            ];
            
            points.forEach(point => {
                const twoThetaRad = point.theta * Math.PI / 180;
                const r = SDD * Math.tan(twoThetaRad);
                const error = (r * r / (2 * SDD * SDD)) * Math.sin(twoThetaRad) * Math.cos(twoThetaRad);
                const errorDeg = error * 180 / Math.PI;
                
                const x = marginLeft + (point.theta / 60) * plotWidth;
                const y = height - marginBottom - (errorDeg / maxError) * plotHeight;
                
                ctx.fillStyle = point.color;
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = point.color;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`${point.label} (${errorDeg.toFixed(3)}Â°)`, x + 10, y - 10);
            });
            
            ctx.textAlign = 'left';
        }
        
        function updateVisualization() {
            const twoTheta = parseInt(angleSlider.value);
            angleValue.textContent = twoTheta + 'Â°';
            
            drawSideView(twoTheta);
            drawFrontView(twoTheta);
        }
        
        // Event listener
        angleSlider.addEventListener('input', updateVisualization);
        
        // Initial draw
        updateVisualization();
        drawErrorPlot();
    </script>
</body>
</html>
